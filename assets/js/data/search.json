[ { "title": "新老生预选赛题目选讲", "url": "/posts/lesson-plan/", "categories": "讲义", "tags": "学习", "date": "2022-10-16 14:07:00 +0000", "snippet": "新老生预选赛题目选讲​\temmm，10月18号了，新生也快要入学了，但是新生们好像并不是很勤勉，希望大家加油啊，要入队了。第一道题 E5题目描述有一个六位数，其个位数字7，现将个位数字移至首位（十万位），而其余各位数字顺序不变，均后退一位，得到一个新的六位数，假如新数为旧数的4倍，求原来的六位数。题目分析这是道填空题啊，打蓝桥杯的时候会遇到，像这种题我们有两种解法，如果是人力可以计算或者能一眼看出来的话就手搓结果就可以了，但如果我们一时想不出啥妙计，就使用程序吧，通过暴力计算，只要能等，程序会给你答案。比如本题，结果是新数为旧数的四倍，所以我们遍历所有新数比旧数即可，可以发现，新数与旧数是数对，通过两个数的关系，我们发现遍历某个范围的数并将其改造成新数与旧数即可。本题可知旧数个位为’7’，新数十万位为’7’，剩下的部分相同，所以建立i通过遍历0~99999，通过公式710000+i/i*10+100007即可得到答案#include&lt;iostream&gt;using namespace std; int main(){\tint a=710000;\tint b=100007;\tfor(int i=0;i&lt;90000;i++){\t\tint k=a+i;\t\tint l=b+i*10;\t\tif(k==4*l){\t\t\tcout&lt;&lt;l;\t\t\tbreak;\t\t}\t}\treturn 0;}第二道题P1045题目描述有一楼梯共 n 级，若每次只能跨上一级或者二级，要走上 n 级，共有多少不同走法？ 给定一个正整数 n ，请返回一个数，代表上楼的方式数。数据保证 n 小于等于 70。题目分析相当经典的一道题，应该学习算法的人都会遇到，可以发现n小于70,说明这道题可以用一些时间复杂度比较高的方法，比如——递归。其实这道题通过观察有更简单的理解，甚至一般人都会先发现更简单的方法，但本着科学严谨的治学态度，我们还是讨论一下关于递归的做法。递归，总的来讲就是分治的思想，本题的思路：可以走一步，也可以走两步，从第n-1阶再走一步能到第n阶，从第n-2阶一次走两步能到第n阶。 所以，f(n)=f(n-1)+f(n-2)。f(n)已经得到了，所以现在要求的就是f(n-1),f(n-2),这样下去，就能通过已知的f(1),f(2)得出结果，显然，大量的重复运算使得这个方法的时间复杂度很高，但有很多题时间复杂度要求并不高，所以递归也是有一定的市场。#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;int jc(ll x);int main(){ ll n,m; cin&gt;&gt;n; cout&lt;&lt;(jc(n));}int jc(ll x){ if(x==0||x==1) return 1;//边界很重要 else return jc(x-1)+jc(x-2);}不过70对于递归来讲似乎都有些大，本题依然有两个样例不能过，那么接下来就是更显而易见的方法，递推。对于递推这个我的理解可能更多的用在发现一定规律的时候，事实上，本题就非常合适，用这个方法，数据规模可以非常高。通过规律，我们发现f(3)=f(1)+f(2),f(4)=f(3)+f(2)…这样就能得出结果，本题和斐波那契数列非常相像，那么下面是代码#include&lt;stdio.h&gt;int main(){\tint n;\tlong long int ans;\tscanf(\"%d\",&amp;n);\tlong long int a=1;\tlong long int b=2;\tlong long int sum=2;\twhile(sum&lt;n){\t\tsum++;\t\tans=a+b;\t\ta=b;\t\tb=ans;\t}\tif(n==1||n==2)printf(\"%d\",n); \telse printf(\"%lld\",ans);\treturn 0;}第三道题P1062题目描述现在要求输入 22 个正整数数 a , b 输出 a+b 的结果1&lt;=a,b 的位数 &lt;= 500保证输入的数字开头不为 0题目分析多么简单的题，c语言一开始就会了！显然，看数据范围，本题没有这么简单，这就是传说中的高精加！？但不过不用紧张，只需要记住这三行代码，就可以解决大部分大数相加的问题（ps：感谢@Alberto提供的技术支持）c[i]+=a[i]+b[i];c[i+1]=c[i]/10;c[i]=c[i]%10;分析上面的代码，我们发现，用数组来代表每一位数字，是相当不错的选择，剩下的就是模拟加法的过程了。可能这题还涉及到一些字符串类型转换之类的，就不过多赘述了，都在码里#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;string A,B;int a[507],b[507],c[507];int main(){ cin&gt;&gt;A&gt;&gt;B; int n=A.size(); int m=B.size(); for(int i=n-1,j=0;i&gt;=0;i--){ a[j]=A[i]-'0'; \tj++; } for(int i=m-1,j=0;i&gt;=0;i--){ b[j]=B[i]-'0'; j++; } n=max(n,m); for(int i=0;i&lt;n;i++){\t\tc[i]+=a[i]+b[i]; c[i+1]=c[i]/10; c[i]=c[i]%10; } if(c[n]!=0)cout&lt;&lt;c[n]; for(int i=n-1;i&gt;=0;i--)cout&lt;&lt;c[i]; return 0;}第四题P1102题目描述将 3 分解成两个正整数的和，有两种分解方法，分别是 3 = 1 + 2 和3 = 2 + 1。注意顺序不同算不同的方法。将 5 分解成三个正整数的和，有 6 种分解方法，它们是 1+1+3 = 1+2+2 =1 + 3 + 1 = 2 + 1 + 2 = 2 + 2 + 1 = 3 + 1 + 1。请问，将 2021 分解成五个正整数的和，有多少种分解方法？题目分析又是一道填空题，所以第一时间想到的就是暴力求解即可。将2021分成五个正整数的和，一开始可能想到五个for循环，事实上也可以这么做，但确实是太慢了。通过观察，我们发现，在选出三个数后，剩下的两个数将会以数对的形式，相加等于2021减去前面三个数，所以，有多少组数对，就代表这三个数下有多少种情况，那么本题就可以缩减到三个for循环即可#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define mod 1000000009#define endl \"\\n\"#define PII pair&lt;int,int&gt;ll ksm(ll a,ll b) {\tll ans = 1;\tfor(;b;b&gt;&gt;=1LL) {\t\tif(b &amp; 1) ans = ans * a % mod;\t\ta = a * a % mod;\t}\treturn ans;}ll lowbit(ll x){return -x &amp; x;}const int N = 2e6+10;int n,a[N];int main(){//\tcout&lt;&lt;691677274345&lt;&lt;endl;//\treturn 0;\tll ans = 1;\tfor(ll i = 2020,j = 1;i &gt;= 2017; --i,++j) {\t\tans *= i;\t\tans /= j;\t}\tcout&lt;&lt;ans&lt;&lt;endl;\t\treturn 0;}//ans = 691677274345PS：谢老师的代码当然更加优秀，所以贴的是他的代码，绝不是因为我懒，另外附上谢老师讲解视频链接https://www.bilibili.com/video/bv11L4y1b7JQ第五题P1037题目描述第二届河南省最美教师评选开始了，每一位同学都可以投票选出你支持的人选，但是为了防止刷票，必须通过身份验证才可投票。负责投票平台后台的老大爷希望你能帮他验证身份证号的合法性，防止那些熊孩子随意刷票，下面给出验证规则： (身份证末尾的大写X表示罗马数字10) 采用了ISO 7064:1983.MOD 11-2校验码，以防止不小心记错某一位plain1、将前面的身份证号码17位数分别乘以不同的系数。从第一位到第十七位的系数分别为：7－9－10－5－8－4－2－1－6－3－7－9－10－5－8－4－2。 2、将这17位数字和系数相乘的结果相加。 3、用加出来和除以11。 4、余数只可能有0－1－2－3－4－5－6－7－8－9－10这11个数字。其分别对应的最后一位身份证的号码为1－0－X －9－8－7－6－5－4－3－2。 5、通过上面得知如果余数是3，就会在身份证的第18位数字上出现的是9。如果对应的数字是2，身份证的最后一位号码就是X。特别注意：“Ⅹ” 是 罗马数字 10， 不是 英文大写字母 “X”， 此处为了编码方便，使用了英文字母 “X” 代替；现在将给你提供一组身份证号码，请判断哪些是合法的，哪些是不合法的。题目分析这题应该算是一道基础题，但想起当初还是给我带来不小的困扰，所以还是挑出来讲了。其实谜底就在谜面上，按照上面的步骤模拟即可，可能需要注意的就是一些写代码时技巧性的东西了#include &lt;iostream&gt;using namespace std;int main(){ int T; cin &gt;&gt; T; while(T--){ char num[20]; cin &gt;&gt; num; if(num[17] == 'X') num[17] = '9' + 1; int cs[] = {7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2}; int res[] = {1,0,10,9,8,7,6,5,4,3,2}; int sum = 0; for(int i = 0; i &lt; 17; i++){ sum += (num[i] - '0') * cs[i]; } sum %= 11; if(res[sum] + '0' == num[17]) cout &lt;&lt; \"True\" &lt;&lt; endl; else cout &lt;&lt; \"False\" &lt;&lt; endl; } return 0;}第六题P1087题目描述设有 n 个活动的集合 E={1,2,..,n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动 i 都有一个要求使用该资源的起始时间 si 和一个结束时间 fi，且 si&lt;fi。如果选择了活动 i ，则它在时间区间[si,fi) 内占用资源。若区间 [si,fi)与区间 [sj,fj) 不相交，则称活动 i 与活动 j 是相容的。也就是说，当 fi≤sj 或 *fj≤si时，活动 i 与活动 j 相容。选择出由互相兼容的活动组成的最大集合。题目分析经典贪心思想的题目，按贪心思想，我们总是留下更多的时间范围来挑选活动，比如[4，7)和[0,5)两个活动，比起时间更短的[4,7)我们更愿意选则[0,5),因为[0,5)结束的更早，也就为之后的活动安排留下更多时间，所以我们总是优先选择最早结束的活动，这就是贪心思想，通过局部最优解，来达到全局最优。在很多题中，我们并不能很明显的考虑到局部最优可以推到全局，但在没有更好的方法时，不妨尝试一下贪心#include&lt;bits/stdc++.h&gt;using namespace std;struct sum{\tint a,b;}suum[1005]; bool cmp(sum x,sum y){\treturn x.b&lt;y.b;}int main(){\tint n,cnt=1,i=0,j=0;\tscanf(\"%d\",&amp;n);\tfor(int i=0;i&lt;n;i++)\t{\t\tscanf(\"%d %d\",&amp;suum[i].a,&amp;suum[i].b);\t}\tsort(suum,suum+n,cmp);\tfor(i=1;i&lt;n;i++)\t{\t\tif(suum[i].a&gt;=suum[j].b)\t\t{\t\t\tj=i;\t\t\tcnt++;\t\t}\t}\tprintf(\"%d\",cnt);\treturn 0;}第七题E895题目描述高考结束了，同学们要开始了紧张的填写志愿的过程，大家希望找一个自己最满意的大学填报方案，请你编程帮忙实现。现有m(m≤100000)所学校，每所学校预计分数线是ai(ai≤106)。有 n(n≤100000)位学生，估分分别为 bi(bi≤106)。根据n位学生的估分情况，分别给每位学生推荐一所学校，要求学校的预计分数线和学生的估分相差最小（可高可低，毕竟是估分嘛），这个最小值为不满意度。求所有学生不满意度和的最小值。题目分析这题首先想到的是暴力，直接一个一个找，但除非是入门基础语法级选手，我们不得不思考暴力时间复杂度上的缺憾，所以我们需要另寻方案。而熟话说二分是更高效的暴力（其实是我说的），所以，我们理所应当考虑到了二分，事实上，本题也确实是二分。下面是我惯用的一套二分模板while(l&lt;=r){ mid=(l+r)&gt;&gt;1; if(check(mid))r=mid-1; else l=mid+1;}二分就是这样一个工具，他可以通过check很高效的结合到任何算法中，化腐朽为神奇，所以很多题没有思路都可以考虑一下二分的可能本题并没有什么弯弯绕绕，二分基本就可以了,但作为初学者，二分过程中的排序当然也是要自己写，才显得够勤勉，所以我们再写一个快速排序，下面是我的快排模板void quick_sort(int l,int r){\tif(l&gt;=r) return ;\tint i=l-1,j=r+1,x=a[(l+r+1)/2];\twhile(i&lt;j){\t\tdo i++;while(a[i]&lt;x);\t\tdo j--;while(a[j]&gt;x);\t\tif(i&lt;j){\t\t\tint t=a[i];\t\t\ta[i]=a[j];\t\t\ta[j]=t;\t\t}\t}\tquick_sort(l,i-1);\tquick_sort(i,r);}那么要素已经集齐了，下面就是AC代码环节#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;const int N=1e5+7;int n,m,i;int a[N],b[N];void quick_sort(int l,int r){\tif(l&gt;=r) return ;\tint i=l-1,j=r+1,x=a[(l+r+1)/2];\twhile(i&lt;j){\t\tdo i++;while(a[i]&lt;x);\t\tdo j--;while(a[j]&gt;x);\t\tif(i&lt;j){\t\t\tint t=a[i];\t\t\ta[i]=a[j];\t\t\ta[j]=t;\t\t}\t}\tquick_sort(l,i-1);\tquick_sort(i,r);}bool check(int x){ if(a[x]&gt;b[i])return true; else return false;}int erfen(int l,int r){ while(l&lt;=r){ int mid=(l+r)&gt;&gt;1; if(check(mid))r=mid-1; \telse l=mid+1; } return r+1;}int main(){ cin&gt;&gt;m&gt;&gt;n; for(int j=1;j&lt;=m;j++)cin&gt;&gt;a[j]; for(int j=1;j&lt;=n;j++)cin&gt;&gt;b[j]; quick_sort(1,m); int ans=0; a[0]=-9999999; for(i=1;i&lt;=n;i++){ int l=erfen(1,m); ans+=min(abs(a[l]-b[i]),min(abs(a[l-1]-b[i]),abs(a[l+1]-b[i])));//这个比较是有必要的，因为本题二分能找到的位置只是包括精确位置在内，旁边一个范围里的位置 } cout&lt;&lt;ans; return 0;}第八题P1028题目描述Krik晚上失眠，躺着很无聊，于是突发奇想道阳台上去看星星。不失所望，那夜繁星当空、星河奔流。Kirk越看越精神，在繁星中发现了一个又一个的数字，刚学编程不久的Kirk想到，电脑上也有星星，何不操作一波呢！经过一番痛苦的敲键盘事件之后，终于Kirk电脑屏幕上出现了下图十个数字的星星表达式：（本来想给文本的，但是文本太丑了）为了让大家体会一下Kirk痛苦的敲代码事件，所以Kirk给你两个整数 A 和 B ，你的任务是计算 A+B 的结果并且使用星星表达式输出结果。题目分析我最喜欢做这种很好看的题了，不过这种题简单但代码一般都很麻烦，比如这道题，我们必须对每个数字进行改编的函数，相当麻烦，但就和前面说的一样，题本身并不困难,只需要一排一排打每个数字就行了，还有一些大佬操作，我一起贴在下面，有兴趣可以看一下（代码来自Kirk题解，话说这种有题解的干嘛不看题解）Kirk佬的代码，很好理解#include &lt;stdio.h&gt;void cout0(int line) { if (line == 1) printf(\"***\"); else if (line == 2) printf(\"* *\"); else if (line == 3) printf(\"* *\"); else if (line == 4) printf(\"* *\"); else if (line == 5) printf(\"***\");}void cout1(int line) { if (line == 1) printf(\" * \"); else if (line == 2) printf(\" * \"); else if (line == 3) printf(\" * \"); else if (line == 4) printf(\" * \"); else if (line == 5) printf(\" * \");}void cout2(int line) { if (line == 1) printf(\"***\"); else if (line == 2) printf(\" *\"); else if (line == 3) printf(\"***\"); else if (line == 4) printf(\"* \"); else if (line == 5) printf(\"***\");}void cout3(int line) { if (line == 1) printf(\"***\"); else if (line == 2) printf(\" *\"); else if (line == 3) printf(\"***\"); else if (line == 4) printf(\" *\"); else if (line == 5) printf(\"***\");}void cout4(int line) { if (line == 1) printf(\"* *\"); else if (line == 2) printf(\"* *\"); else if (line == 3) printf(\"***\"); else if (line == 4) printf(\" *\"); else if (line == 5) printf(\" *\");}void cout5(int line) { if (line == 1) printf(\"***\"); else if (line == 2) printf(\"* \"); else if (line == 3) printf(\"***\"); else if (line == 4) printf(\" *\"); else if (line == 5) printf(\"***\");}void cout6(int line) { if (line == 1) printf(\"***\"); else if (line == 2) printf(\"* \"); else if (line == 3) printf(\"***\"); else if (line == 4) printf(\"* *\"); else if (line == 5) printf(\"***\");}void cout7(int line) { if (line == 1) printf(\"***\"); else if (line == 2) printf(\" *\"); else if (line == 3) printf(\" *\"); else if (line == 4) printf(\" *\"); else if (line == 5) printf(\" *\");}void cout8(int line) { if (line == 1) printf(\"***\"); else if (line == 2) printf(\"* *\"); else if (line == 3) printf(\"***\"); else if (line == 4) printf(\"* *\"); else if (line == 5) printf(\"***\");}void cout9(int line) { if (line == 1) printf(\"***\"); else if (line == 2) printf(\"* *\"); else if (line == 3) printf(\"***\"); else if (line == 4) printf(\" *\"); else if (line == 5) printf(\"***\");}int main() { int A, B; scanf(\"%d%d\", &amp;A, &amp;B); int res = A + B; // 数据保证 10 &lt;= A + B &lt; 100 int num1 = res / 10; int num2 = res % 10; for (int j = 1; j &lt;= 6; j++) { if (num1 == 0) cout0(j); else if (num1 == 1) cout1(j); else if (num1 == 2) cout2(j); else if (num1 == 3) cout3(j); else if (num1 == 4) cout4(j); else if (num1 == 5) cout5(j); else if (num1 == 6) cout6(j); else if (num1 == 7) cout7(j); else if (num1 == 8) cout8(j); else if (num1 == 9) cout9(j); putchar(' '); if (num2 == 0) cout0(j); else if (num2 == 1) cout1(j); else if (num2 == 2) cout2(j); else if (num2 == 3) cout3(j); else if (num2 == 4) cout4(j); else if (num2 == 5) cout5(j); else if (num2 == 6) cout6(j); else if (num2 == 7) cout7(j); else if (num2 == 8) cout8(j); else if (num2 == 9) cout9(j); putchar('\\n'); } return 0;}未知大佬的代码1#include&lt;iostream&gt;using namespace std;string x[15][10];int ans[105],cou;int main(){\tios::sync_with_stdio(false);\tx[0][0]=\"***\";\tx[0][1]=\"* *\";\tx[0][2]=\"* *\";\tx[0][3]=\"* *\";\tx[0][4]=\"***\";\t\tx[1][0]=\" * \";\tx[1][1]=\" * \";\tx[1][2]=\" * \";\tx[1][3]=\" * \";\tx[1][4]=\" * \";\t\tx[2][0]=\"***\";\tx[2][1]=\" *\";\tx[2][2]=\"***\";\tx[2][3]=\"* \";\tx[2][4]=\"***\";\t\tx[3][0]=\"***\";\tx[3][1]=\" *\";\tx[3][2]=\"***\";\tx[3][3]=\" *\";\tx[3][4]=\"***\";\t\tx[4][0]=\"* *\";\tx[4][1]=\"* *\";\tx[4][2]=\"***\";\tx[4][3]=\" *\";\tx[4][4]=\" *\";\t\tx[5][0]=\"***\";\tx[5][1]=\"* \";\tx[5][2]=\"***\";\tx[5][3]=\" *\";\tx[5][4]=\"***\";\t\tx[6][0]=\"***\";\tx[6][1]=\"* \";\tx[6][2]=\"***\";\tx[6][3]=\"* *\";\tx[6][4]=\"***\";\t\tx[7][0]=\"***\";\tx[7][1]=\" *\";\tx[7][2]=\" *\";\tx[7][3]=\" *\";\tx[7][4]=\" *\";\t\tx[8][0]=\"***\";\tx[8][1]=\"* *\";\tx[8][2]=\"***\";\tx[8][3]=\"* *\";\tx[8][4]=\"***\";\t\tx[9][0]=\"***\";\tx[9][1]=\"* *\";\tx[9][2]=\"***\";\tx[9][3]=\" *\";\tx[9][4]=\"***\";\t\tint a,b;\tcin&gt;&gt;a&gt;&gt;b;\tint xx=a+b,y=0,yy;\twhile(xx){\t\tans[cou++]=xx%10;\t\txx/=10;\t}\tfor(int i=0;i&lt;5;i++){\t\tyy=y;\t\tfor(int j=cou-1;j&gt;=0;j--){\t\t\tcout&lt;&lt;x[ans[j]][i];\t\t\tif(j)cout&lt;&lt;' ';\t\t}\t\tcout&lt;&lt;endl;\t}\t\t\t\treturn 0;}#include&lt;iostream&gt;using namespace std;char n0[6][6]={\"***\",\"* *\",\"* *\",\"* *\",\"***\"},n1[6][6]={\" * \",\" * \",\" * \",\" * \",\" * \"};char n2[6][6]={\"***\",\" *\",\"***\",\"* \",\"***\"},n3[6][6]={\"***\",\" *\",\"***\",\" *\",\"***\"};char n4[6][6]={\"* *\",\"* *\",\"***\",\" *\",\" *\"},n5[6][6]={\"***\",\"* \",\"***\",\" *\",\"***\"};char n6[6][6]={\"***\",\"* \",\"***\",\"* *\",\"***\"},n7[6][6]={\"***\",\" *\",\" *\",\" *\",\" *\"};char n8[6][6]={\"***\",\"* *\",\"***\",\"* *\",\"***\"},n9[6][6]={\"***\",\"* *\",\"***\",\" *\",\"***\"};int main(){\tint a,b;\tcin&gt;&gt;a&gt;&gt;b;\tint c=a+b;\tchar s[3];\ts[1]=c/10;\ts[2]=c%10;\tint flag=0;\t\t\tfor(int p=0;p&lt;5;p++)\t\t\t{\t\t\t\tfor(int j=1;j&lt;3;j++)\t\t\t\t{\t\t\t\t\tif(s[j]==1)cout&lt;&lt;n1[p];\t\t\t\t\tif(s[j]==2)cout&lt;&lt;n2[p];\t\t\t\t\tif(s[j]==3)cout&lt;&lt;n3[p];\t\t\t\t\tif(s[j]==4)cout&lt;&lt;n4[p];\t\t\t\t\tif(s[j]==5)cout&lt;&lt;n5[p];\t\t\t\t\tif(s[j]==6)cout&lt;&lt;n6[p];\t\t\t\t\tif(s[j]==7)cout&lt;&lt;n7[p];\t\t\t\t\tif(s[j]==8)cout&lt;&lt;n8[p];\t\t\t\t\tif(s[j]==9)cout&lt;&lt;n9[p];\t\t\t\t\tif(s[j]==0)cout&lt;&lt;n0[p]; if(j==1)cout&lt;&lt;\" \";\t\t\t\t}\t\t\t\tcout&lt;&lt;\"\\n\";\t}\treturn 0;}未知大佬的代码2#include&lt;iostream&gt;using namespace std;char n0[6][6]={\"***\",\"* *\",\"* *\",\"* *\",\"***\"},n1[6][6]={\" * \",\" * \",\" * \",\" * \",\" * \"};char n2[6][6]={\"***\",\" *\",\"***\",\"* \",\"***\"},n3[6][6]={\"***\",\" *\",\"***\",\" *\",\"***\"};char n4[6][6]={\"* *\",\"* *\",\"***\",\" *\",\" *\"},n5[6][6]={\"***\",\"* \",\"***\",\" *\",\"***\"};char n6[6][6]={\"***\",\"* \",\"***\",\"* *\",\"***\"},n7[6][6]={\"***\",\" *\",\" *\",\" *\",\" *\"};char n8[6][6]={\"***\",\"* *\",\"***\",\"* *\",\"***\"},n9[6][6]={\"***\",\"* *\",\"***\",\" *\",\"***\"};int main(){\tint a,b;\tcin&gt;&gt;a&gt;&gt;b;\tint c=a+b;\tchar s[3];\ts[1]=c/10;\ts[2]=c%10;\tint flag=0;\t\t\tfor(int p=0;p&lt;5;p++)\t\t\t{\t\t\t\tfor(int j=1;j&lt;3;j++)\t\t\t\t{\t\t\t\t\tif(s[j]==1)cout&lt;&lt;n1[p];\t\t\t\t\tif(s[j]==2)cout&lt;&lt;n2[p];\t\t\t\t\tif(s[j]==3)cout&lt;&lt;n3[p];\t\t\t\t\tif(s[j]==4)cout&lt;&lt;n4[p];\t\t\t\t\tif(s[j]==5)cout&lt;&lt;n5[p];\t\t\t\t\tif(s[j]==6)cout&lt;&lt;n6[p];\t\t\t\t\tif(s[j]==7)cout&lt;&lt;n7[p];\t\t\t\t\tif(s[j]==8)cout&lt;&lt;n8[p];\t\t\t\t\tif(s[j]==9)cout&lt;&lt;n9[p];\t\t\t\t\tif(s[j]==0)cout&lt;&lt;n0[p]; if(j==1)cout&lt;&lt;\" \";\t\t\t\t}\t\t\t\tcout&lt;&lt;\"\\n\";\t}\treturn 0;}本蒟蒻的代码#include&lt;iostream&gt;using namespace std;void cou(int x,int line){ if(line==1){\t\tif(x==0||x==2||x==3||x==5||x==6||x==7||x==8||x==9)cout&lt;&lt;\"***\"; if(x==1)cout&lt;&lt;\" * \"; if(x==4)cout&lt;&lt;\"* *\"; } if(line==2){ if(x==0||x==4||x==8||x==9)cout&lt;&lt;\"* *\"; if(x==1)cout&lt;&lt;\" * \"; if(x==2||x==3||x==7)cout&lt;&lt;\" *\"; if(x==5||x==6)cout&lt;&lt;\"* \"; } if(line==3){\t\tif(x==0)cout&lt;&lt;\"* *\"; if(x==1)cout&lt;&lt;\" * \"; if(x==2||x==3||x==4||x==5||x==6||x==8||x==9)cout&lt;&lt;\"***\"; if(x==7)cout&lt;&lt;\" *\"; } if(line==4){\t\tif(x==0||x==6||x==8)cout&lt;&lt;\"* *\"; if(x==1)cout&lt;&lt;\" * \"; if(x==2)cout&lt;&lt;\"* \"; if(x==3||x==4||x==5||x==7||x==9)cout&lt;&lt;\" *\"; } if(line==5){ if(x==0||x==2||x==3||x==5||x==6||x==8||x==9)cout&lt;&lt;\"***\"; if(x==1)cout&lt;&lt;\" * \"; if(x==4||x==7)cout&lt;&lt;\" *\"; }}int main(){ int a,b; cin&gt;&gt;a&gt;&gt;b; int c=a+b; b=c%10; a=(c-b)/10; for(int i=1;i&lt;=5;i++){ cou(a,i); cout&lt;&lt;\" \"; cou(b,i); cout&lt;&lt;endl; } return 0;}就是这样，喵~结语那么，我的第一次讲题就到此结束了，不足之处还望指正" }, { "title": "「一本通 1.2 练习 2」扩散（经典题型精析）", "url": "/posts/kmp_and_-sort/", "categories": "例题", "tags": "学习", "date": "2022-10-16 01:48:00 +0000", "snippet": "并查集求距离题目描述一个点每过一个单位时间就会向 4 个方向扩散一个距离，如图所示：两个点 a 、b 连通，记作 e(a,b)，当且仅当 a 、b 的扩散区域有公共部分。连通块的定义是块内的任意两个点 u、v 都必定存在路径e(u, a_0 ),e(a0,a_1),…e(ak,v)。给定平面上的 n 个点，问最早什么时候它们形成一个连通块。输入格式第一行一个数 n ，以下 n 行，每行一个点坐标。输出格式输出仅一个数，表示最早的时刻所有点形成连通块。样例输入20 05 5输出5数据范围与提示对于 20% 的数据，满足 1≤n≤5,1≤Xi,Yi≤50；对于 100\\%100% 的数据，满足 1≤n≤50,1≤Xi,Yi≤10^9。思路分析Floyd算法本题有两种解法，一是floyd，二是并查集求距离。本题的floyd算法比较常规，经典的是并查集加二分的思路，可以说是非常的巧妙。但是俗话说的好，来都来了，不如就把floyd的思路同样分析一下。floydfor(int k=0;k&lt;n;k++){ for(int i=0;i&lt;n;i++){\t\tfor(int j=0;j&lt;n;j++){ if(j!=i&amp;&amp;j!=k)v[i][j]=min(v[i][j],max(v[i][k],v[k][j])); } }}我们需要一个函数来求距离：距离for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;n;j++){\t\tif(i!=j){\t\t\tv[i][j]=abs(x[i]-x[j])+abs(y[i]-y[j]); } }}因为结束时间为最长距离的连接时间，所以最后我们求最长距离即可：最长距离for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;n;j++){ ans=max(ans,v[i][j]); }}那么万物皆虚,万事皆允，我们来看看最终代码吧：代码实现1#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;const int N=57;int n;int x[N],y[N];int v[N][N];void find_distance(){\tfor(int i=0;i&lt;n;i++){ \tfor(int j=0;j&lt;n;j++){\t\t\tif(i!=j){\t\t\t\tv[i][j]=v[j][i]=abs(x[i]-x[j])+abs(y[i]-y[j]); \t\t\t} \t}\t}}void floyd(){ for(int k=0;k&lt;n;k++){ \tfor(int i=0;i&lt;n;i++){\t\t\tfor(int j=0;j&lt;n;j++){ \tif(j!=i&amp;&amp;j!=k)v[i][j]=min(v[i][j],max(v[i][k],v[k][j])); \t} \t}\t}}void find_ans(){ int ans=0; for(int i=0;i&lt;n;i++){ \tfor(int j=0;j&lt;n;j++){ \t ans=max(ans,v[i][j]); \t\t}\t} cout&lt;&lt;(ans+1)/2;}int main(){\tcin&gt;&gt;n;\tfor(int i=0;i&lt;n;i++){\t\tcin&gt;&gt;x[i]&gt;&gt;y[i];\t}\tfind_distance();\tfloyd();\tfind_ans();\treturn 0;}floyd+dp已经结束辣！下面是这道题更为精妙的做法：并查集+二分！并查集+二分二分有一种我自己的理解方式是这样的，通过二分来查找某一个答案，来缩减问题的难度，二分本质是更高效的遍历！！！例如本题，我们通过二分来遍历最小时间，通过并查集来检查是否连通，如果连通就继续减少时间，如果不连通，就扩大，下面是代码环节：二分while(l&lt;=r){ mid=(l+r)&gt;&gt;1; if(check(mid))r=mid-1; else l=mid+1;}并查集+checkfor(int i=0;i&lt;n;i++)fa[i]=i;for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;n;j++){ if(v[i][j]&lt;=2*x){ int fx=f(i),fy=f(j); if(fx!=fy)fa[fx]=fy; } }}int sum = 0 ;for(int i=0;i&lt;n;i++){ if(fa[i]==i)sum++; if(sum==2)return false;}return true;距离for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;n;j++){\t\tif(i!=j){\t\t\tv[i][j]=abs(x[i]-x[j])+abs(y[i]-y[j]); } }}查找祖先if(x==fa[x])return x;else return fa[x]=find(fa[x]);来看看最终代码吧：代码实现2#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;const int N=57;int n;int fa[N];int v[N][N];int x[N],y[N];int f(int x){ if(x==fa[x])return x;\telse return fa[x]=f(fa[x]);}void find_distance(){ for(int i=0;i&lt;n;i++){ \tfor(int j=0;j&lt;n;j++){\t\t\tif(i!=j){\t\t\t\tv[i][j]=abs(x[i]-x[j])+abs(y[i]-y[j]); \t} \t}\t}}bool check(int x){ for(int i=0;i&lt;n;i++)fa[i]=i;\tfor(int i=0;i&lt;n;i++){ \tfor(int j=0;j&lt;n;j++){ \tif(v[i][j]&lt;=2*x){ \tint fx=f(i),fy=f(j); \t\tif(fx!=fy)fa[fx]=fy; \t} \t}\t}\tint sum = 0 ;\tfor(int i=0;i&lt;n;i++){ \tif(fa[i]==i)sum++; \tif(sum==2)return false;\t}\treturn true;}int erfen(int l,int r){ int mid; while(l&lt;=r){ \tmid=(l+r)&gt;&gt;1; \tif(check(mid))r=mid-1; \telse l=mid+1;\t} return r+1;}int main(){ cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;x[i]&gt;&gt;y[i]; find_distance(); int ans=erfen(0,999999999); cout&lt;&lt;ans; return 0;}至此，关于本题的分享就到此结束了" }, { "title": "你好，世界！", "url": "/posts/hello-world/", "categories": "随笔", "tags": "学习", "date": "2022-10-16 01:48:00 +0000", "snippet": "Hello World ~include&lt;iostream&gt;using namespace std;int main(){ printf(\"Hello world~\"); return 0;}这是我博客的第一篇文章，也是一个开始，感谢 @汤姆还在写代码 提供的博客框架，以及博客使用方法" } ]
